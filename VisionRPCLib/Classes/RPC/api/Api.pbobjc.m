// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Api.pbobjc.h"
#import "Vision.pbobjc.h"
#import "Annotations.pbobjc.h"
#import "AssetIssueContract.pbobjc.h"
#import "AccountContract.pbobjc.h"
#import "WitnessContract.pbobjc.h"
#import "BalanceContract.pbobjc.h"
#import "ProposalContract.pbobjc.h"
#import "StorageContract.pbobjc.h"
#import "ExchangeContract.pbobjc.h"
#import "MarketContract.pbobjc.h"
#import "SmartContract.pbobjc.h"
#import "ShieldContract.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Account);
GPBObjCClassDeclaration(AccountPhotonMessage);
GPBObjCClassDeclaration(AccountResourceMessage);
GPBObjCClassDeclaration(Address);
GPBObjCClassDeclaration(AssetIssueContract);
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockExtention);
GPBObjCClassDeclaration(BlockHeader);
GPBObjCClassDeclaration(BytesMessage);
GPBObjCClassDeclaration(DecryptNotes);
GPBObjCClassDeclaration(DecryptNotesMarked);
GPBObjCClassDeclaration(DecryptNotesMarked_NoteTx);
GPBObjCClassDeclaration(DecryptNotesVRC20);
GPBObjCClassDeclaration(DecryptNotesVRC20_NoteTx);
GPBObjCClassDeclaration(DecryptNotes_NoteTx);
GPBObjCClassDeclaration(DelegatedResource);
GPBObjCClassDeclaration(DiversifierMessage);
GPBObjCClassDeclaration(Exchange);
GPBObjCClassDeclaration(IncomingViewingKeyMessage);
GPBObjCClassDeclaration(IncrementalMerkleTree);
GPBObjCClassDeclaration(IncrementalMerkleVoucher);
GPBObjCClassDeclaration(Node);
GPBObjCClassDeclaration(Note);
GPBObjCClassDeclaration(Permission);
GPBObjCClassDeclaration(Proposal);
GPBObjCClassDeclaration(ReceiveDescription);
GPBObjCClassDeclaration(ReceiveNote);
GPBObjCClassDeclaration(Return);
GPBObjCClassDeclaration(ShieldedVRC20Parameters);
GPBObjCClassDeclaration(SpendDescription);
GPBObjCClassDeclaration(SpendNote);
GPBObjCClassDeclaration(SpendNoteVRC20);
GPBObjCClassDeclaration(SpreadRelationShip);
GPBObjCClassDeclaration(TimeMessage);
GPBObjCClassDeclaration(Transaction);
GPBObjCClassDeclaration(TransactionApprovedList);
GPBObjCClassDeclaration(TransactionApprovedList_Result);
GPBObjCClassDeclaration(TransactionExtention);
GPBObjCClassDeclaration(TransactionInfo);
GPBObjCClassDeclaration(TransactionSignWeight);
GPBObjCClassDeclaration(TransactionSignWeight_Result);
GPBObjCClassDeclaration(Witness);

#pragma mark - ApiRoot

@implementation ApiRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - ApiRoot_FileDescriptor

static GPBFileDescriptor *ApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Return

@implementation Return

@dynamic result;
@dynamic code;
@dynamic message;

typedef struct Return__storage_ {
  uint32_t _has_storage_[1];
  Return_response_code code;
  NSData *message;
} Return__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.clazz = Nil,
        .number = Return_FieldNumber_Result,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = Return_response_code_EnumDescriptor,
        .number = Return_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Return__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = Return_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Return__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Return class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Return__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Return_Code_RawValue(Return *message) {
  GPBDescriptor *descriptor = [Return descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Return_FieldNumber_Code];
  return GPBGetMessageRawEnumField(message, field);
}

void SetReturn_Code_RawValue(Return *message, int32_t value) {
  GPBDescriptor *descriptor = [Return descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Return_FieldNumber_Code];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Return_response_code

GPBEnumDescriptor *Return_response_code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Sigerror\000ContractValidateError\000C"
        "ontractExeError\000PhotonError\000DupTransacti"
        "onError\000TaposError\000TooBigTransactionErro"
        "r\000TransactionExpirationError\000ServerBusy\000"
        "NoConnection\000NotEnoughEffectiveConnectio"
        "n\000OtherError\000";
    static const int32_t values[] = {
        Return_response_code_Success,
        Return_response_code_Sigerror,
        Return_response_code_ContractValidateError,
        Return_response_code_ContractExeError,
        Return_response_code_PhotonError,
        Return_response_code_DupTransactionError,
        Return_response_code_TaposError,
        Return_response_code_TooBigTransactionError,
        Return_response_code_TransactionExpirationError,
        Return_response_code_ServerBusy,
        Return_response_code_NoConnection,
        Return_response_code_NotEnoughEffectiveConnection,
        Return_response_code_OtherError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Return_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Return_response_code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Return_response_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case Return_response_code_Success:
    case Return_response_code_Sigerror:
    case Return_response_code_ContractValidateError:
    case Return_response_code_ContractExeError:
    case Return_response_code_PhotonError:
    case Return_response_code_DupTransactionError:
    case Return_response_code_TaposError:
    case Return_response_code_TooBigTransactionError:
    case Return_response_code_TransactionExpirationError:
    case Return_response_code_ServerBusy:
    case Return_response_code_NoConnection:
    case Return_response_code_NotEnoughEffectiveConnection:
    case Return_response_code_OtherError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockReference

@implementation BlockReference

@dynamic blockNum;
@dynamic blockHash;

typedef struct BlockReference__storage_ {
  uint32_t _has_storage_[1];
  NSData *blockHash;
  int64_t blockNum;
} BlockReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNum",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockReference_FieldNumber_BlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockReference__storage_, blockNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockReference_FieldNumber_BlockHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockReference__storage_, blockHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockReference class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WitnessList

@implementation WitnessList

@dynamic witnessesArray, witnessesArray_Count;

typedef struct WitnessList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *witnessesArray;
} WitnessList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "witnessesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Witness),
        .number = WitnessList_FieldNumber_WitnessesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WitnessList__storage_, witnessesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WitnessList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WitnessList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProposalList

@implementation ProposalList

@dynamic proposalsArray, proposalsArray_Count;

typedef struct ProposalList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *proposalsArray;
} ProposalList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proposalsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Proposal),
        .number = ProposalList_FieldNumber_ProposalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProposalList__storage_, proposalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProposalList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProposalList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExchangeList

@implementation ExchangeList

@dynamic exchangesArray, exchangesArray_Count;

typedef struct ExchangeList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *exchangesArray;
} ExchangeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Exchange),
        .number = ExchangeList_FieldNumber_ExchangesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExchangeList__storage_, exchangesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExchangeList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExchangeList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetIssueList

@implementation AssetIssueList

@dynamic assetIssueArray, assetIssueArray_Count;

typedef struct AssetIssueList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *assetIssueArray;
} AssetIssueList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetIssueArray",
        .dataTypeSpecific.clazz = GPBObjCClass(AssetIssueContract),
        .number = AssetIssueList_FieldNumber_AssetIssueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssetIssueList__storage_, assetIssueArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetIssueList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetIssueList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000assetIssue\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockList

@implementation BlockList

@dynamic blockArray, blockArray_Count;

typedef struct BlockList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockArray;
} BlockList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = BlockList_FieldNumber_BlockArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockList__storage_, blockArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionList

@implementation TransactionList

@dynamic transactionArray, transactionArray_Count;

typedef struct TransactionList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionArray;
} TransactionList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = TransactionList_FieldNumber_TransactionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionList__storage_, transactionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegatedResourceMessage

@implementation DelegatedResourceMessage

@dynamic fromAddress;
@dynamic toAddress;

typedef struct DelegatedResourceMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *fromAddress;
  NSData *toAddress;
} DelegatedResourceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegatedResourceMessage_FieldNumber_FromAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegatedResourceMessage__storage_, fromAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegatedResourceMessage_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelegatedResourceMessage__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelegatedResourceMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegatedResourceList

@implementation DelegatedResourceList

@dynamic delegatedResourceArray, delegatedResourceArray_Count;

typedef struct DelegatedResourceList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *delegatedResourceArray;
} DelegatedResourceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatedResourceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DelegatedResource),
        .number = DelegatedResourceList_FieldNumber_DelegatedResourceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelegatedResourceList__storage_, delegatedResourceArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelegatedResourceList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000delegatedResource\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpreadRelationShipMessage

@implementation SpreadRelationShipMessage

@dynamic ownerAddress;
@dynamic parentAddress;
@dynamic level;
@dynamic address;

typedef struct SpreadRelationShipMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  NSData *ownerAddress;
  NSData *parentAddress;
  NSData *address;
} SpreadRelationShipMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = SpreadRelationShipMessage_FieldNumber_OwnerAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpreadRelationShipMessage__storage_, ownerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parentAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = SpreadRelationShipMessage_FieldNumber_ParentAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpreadRelationShipMessage__storage_, parentAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SpreadRelationShipMessage_FieldNumber_Level,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpreadRelationShipMessage__storage_, level),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = SpreadRelationShipMessage_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SpreadRelationShipMessage__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpreadRelationShipMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpreadRelationShipMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpreadRelationShipList

@implementation SpreadRelationShipList

@dynamic spreadRelationShipArray, spreadRelationShipArray_Count;

typedef struct SpreadRelationShipList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *spreadRelationShipArray;
} SpreadRelationShipList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spreadRelationShipArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpreadRelationShip),
        .number = SpreadRelationShipList_FieldNumber_SpreadRelationShipArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SpreadRelationShipList__storage_, spreadRelationShipArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpreadRelationShipList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpreadRelationShipList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000spreadRelationShip\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeList

@implementation NodeList

@dynamic nodesArray, nodesArray_Count;

typedef struct NodeList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodesArray;
} NodeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Node),
        .number = NodeList_FieldNumber_NodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeList__storage_, nodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Node

@implementation Node

@dynamic hasAddress, address;

typedef struct Node__storage_ {
  uint32_t _has_storage_[1];
  Address *address;
} Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = GPBObjCClass(Address),
        .number = Node_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Node__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Node class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Node__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Address

@implementation Address

@dynamic host;
@dynamic port;

typedef struct Address__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSData *host;
} Address__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "host",
        .dataTypeSpecific.clazz = Nil,
        .number = Address_FieldNumber_Host,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Address__storage_, host),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = Address_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Address__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Address class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Address__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmptyMessage

@implementation EmptyMessage


typedef struct EmptyMessage__storage_ {
  uint32_t _has_storage_[1];
} EmptyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmptyMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EmptyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NumberMessage

@implementation NumberMessage

@dynamic num;

typedef struct NumberMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t num;
} NumberMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "num",
        .dataTypeSpecific.clazz = Nil,
        .number = NumberMessage_FieldNumber_Num,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NumberMessage__storage_, num),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NumberMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NumberMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RewardMessage

@implementation RewardMessage

@dynamic reward;
@dynamic spreadReward;

typedef struct RewardMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t reward;
  int64_t spreadReward;
} RewardMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reward",
        .dataTypeSpecific.clazz = Nil,
        .number = RewardMessage_FieldNumber_Reward,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RewardMessage__storage_, reward),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "spreadReward",
        .dataTypeSpecific.clazz = Nil,
        .number = RewardMessage_FieldNumber_SpreadReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RewardMessage__storage_, spreadReward),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RewardMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RewardMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BytesMessage

@implementation BytesMessage

@dynamic value;

typedef struct BytesMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} BytesMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = BytesMessage_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BytesMessage__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BytesMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BytesMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimeMessage

@implementation TimeMessage

@dynamic beginInMilliseconds;
@dynamic endInMilliseconds;

typedef struct TimeMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t beginInMilliseconds;
  int64_t endInMilliseconds;
} TimeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "beginInMilliseconds",
        .dataTypeSpecific.clazz = Nil,
        .number = TimeMessage_FieldNumber_BeginInMilliseconds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimeMessage__storage_, beginInMilliseconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endInMilliseconds",
        .dataTypeSpecific.clazz = Nil,
        .number = TimeMessage_FieldNumber_EndInMilliseconds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimeMessage__storage_, endInMilliseconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimeMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimeMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\023\000\002\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockLimit

@implementation BlockLimit

@dynamic startNum;
@dynamic endNum;

typedef struct BlockLimit__storage_ {
  uint32_t _has_storage_[1];
  int64_t startNum;
  int64_t endNum;
} BlockLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startNum",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockLimit_FieldNumber_StartNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockLimit__storage_, startNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endNum",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockLimit_FieldNumber_EndNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockLimit__storage_, endNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockLimit class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockLimit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionLimit

@implementation TransactionLimit

@dynamic transactionId;
@dynamic limitNum;

typedef struct TransactionLimit__storage_ {
  uint32_t _has_storage_[1];
  NSData *transactionId;
  int64_t limitNum;
} TransactionLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionId",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionLimit_FieldNumber_TransactionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionLimit__storage_, transactionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "limitNum",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionLimit_FieldNumber_LimitNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionLimit__storage_, limitNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionLimit class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionLimit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\r\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountPaginated

@implementation AccountPaginated

@dynamic hasAccount, account;
@dynamic offset;
@dynamic limit;

typedef struct AccountPaginated__storage_ {
  uint32_t _has_storage_[1];
  Account *account;
  int64_t offset;
  int64_t limit;
} AccountPaginated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.clazz = GPBObjCClass(Account),
        .number = AccountPaginated_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountPaginated__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPaginated_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountPaginated__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPaginated_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountPaginated__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountPaginated class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountPaginated__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimePaginatedMessage

@implementation TimePaginatedMessage

@dynamic hasTimeMessage, timeMessage;
@dynamic offset;
@dynamic limit;

typedef struct TimePaginatedMessage__storage_ {
  uint32_t _has_storage_[1];
  TimeMessage *timeMessage;
  int64_t offset;
  int64_t limit;
} TimePaginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(TimeMessage),
        .number = TimePaginatedMessage_FieldNumber_TimeMessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, timeMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = TimePaginatedMessage_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = TimePaginatedMessage_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TimePaginatedMessage__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimePaginatedMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimePaginatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountPhotonMessage

@implementation AccountPhotonMessage

@dynamic freePhotonUsed;
@dynamic freePhotonLimit;
@dynamic photonUsed;
@dynamic photonLimit;
@dynamic assetPhotonUsed, assetPhotonUsed_Count;
@dynamic assetPhotonLimit, assetPhotonLimit_Count;
@dynamic totalPhotonLimit;
@dynamic totalPhotonWeight;

typedef struct AccountPhotonMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt64Dictionary *assetPhotonUsed;
  GPBStringInt64Dictionary *assetPhotonLimit;
  int64_t freePhotonUsed;
  int64_t freePhotonLimit;
  int64_t photonUsed;
  int64_t photonLimit;
  int64_t totalPhotonLimit;
  int64_t totalPhotonWeight;
} AccountPhotonMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "freePhotonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_FreePhotonUsed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, freePhotonUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freePhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_FreePhotonLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, freePhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "photonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_PhotonUsed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, photonUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "photonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_PhotonLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, photonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetPhotonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_AssetPhotonUsed,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, assetPhotonUsed),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetPhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_AssetPhotonLimit,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, assetPhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalPhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_TotalPhotonLimit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, totalPhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalPhotonWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountPhotonMessage_FieldNumber_TotalPhotonWeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AccountPhotonMessage__storage_, totalPhotonWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountPhotonMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountPhotonMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\016\000\002\017\000\003J\000\004K\000\005\017\000\006\020\000\007P\000\010Q\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountResourceMessage

@implementation AccountResourceMessage

@dynamic freePhotonUsed;
@dynamic freePhotonLimit;
@dynamic photonUsed;
@dynamic photonLimit;
@dynamic assetPhotonUsed, assetPhotonUsed_Count;
@dynamic assetPhotonLimit, assetPhotonLimit_Count;
@dynamic totalPhotonLimit;
@dynamic totalPhotonWeight;
@dynamic entropyUsed;
@dynamic entropyLimit;
@dynamic totalEntropyLimit;
@dynamic totalEntropyWeight;
@dynamic storageUsed;
@dynamic storageLimit;
@dynamic totalFvguaranteeWeight;
@dynamic totalSpreadWeight;

typedef struct AccountResourceMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt64Dictionary *assetPhotonUsed;
  GPBStringInt64Dictionary *assetPhotonLimit;
  int64_t freePhotonUsed;
  int64_t freePhotonLimit;
  int64_t photonUsed;
  int64_t photonLimit;
  int64_t totalPhotonLimit;
  int64_t totalPhotonWeight;
  int64_t entropyUsed;
  int64_t entropyLimit;
  int64_t totalEntropyLimit;
  int64_t totalEntropyWeight;
  int64_t storageUsed;
  int64_t storageLimit;
  int64_t totalFvguaranteeWeight;
  int64_t totalSpreadWeight;
} AccountResourceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "freePhotonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_FreePhotonUsed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, freePhotonUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freePhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_FreePhotonLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, freePhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "photonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_PhotonUsed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, photonUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "photonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_PhotonLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, photonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetPhotonUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_AssetPhotonUsed,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, assetPhotonUsed),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetPhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_AssetPhotonLimit,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, assetPhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalPhotonLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalPhotonLimit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalPhotonLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalPhotonWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalPhotonWeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalPhotonWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "entropyUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_EntropyUsed,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, entropyUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "entropyLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_EntropyLimit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, entropyLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalEntropyLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalEntropyLimit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalEntropyLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalEntropyWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalEntropyWeight,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalEntropyWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_StorageUsed,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, storageUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_StorageLimit,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, storageLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalFvguaranteeWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalFvguaranteeWeight,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalFvguaranteeWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSpreadWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResourceMessage_FieldNumber_TotalSpreadWeight,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AccountResourceMessage__storage_, totalSpreadWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountResourceMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResourceMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\020\001\016\000\002\017\000\003J\000\004K\000\005\017\000\006\020\000\007P\000\010Q\000\rK\000\016L\000\017Q\000\020R\000\025\013\000"
        "\026\014\000\033Fb\016\000 Q\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaginatedMessage

@implementation PaginatedMessage

@dynamic offset;
@dynamic limit;

typedef struct PaginatedMessage__storage_ {
  uint32_t _has_storage_[1];
  int64_t offset;
  int64_t limit;
} PaginatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = PaginatedMessage_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaginatedMessage__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = PaginatedMessage_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaginatedMessage__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaginatedMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaginatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EasyTransferMessage

@implementation EasyTransferMessage

@dynamic passPhrase;
@dynamic toAddress;
@dynamic amount;

typedef struct EasyTransferMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *passPhrase;
  NSData *toAddress;
  int64_t amount;
} EasyTransferMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "passPhrase",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferMessage_FieldNumber_PassPhrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EasyTransferMessage__storage_, passPhrase),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferMessage_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EasyTransferMessage__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EasyTransferMessage__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EasyTransferMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EasyTransferMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EasyTransferAssetMessage

@implementation EasyTransferAssetMessage

@dynamic passPhrase;
@dynamic toAddress;
@dynamic assetId;
@dynamic amount;

typedef struct EasyTransferAssetMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *passPhrase;
  NSData *toAddress;
  NSString *assetId;
  int64_t amount;
} EasyTransferAssetMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "passPhrase",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetMessage_FieldNumber_PassPhrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EasyTransferAssetMessage__storage_, passPhrase),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetMessage_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EasyTransferAssetMessage__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetMessage_FieldNumber_AssetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EasyTransferAssetMessage__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetMessage_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EasyTransferAssetMessage__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EasyTransferAssetMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EasyTransferAssetMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\n\000\002\t\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EasyTransferByPrivateMessage

@implementation EasyTransferByPrivateMessage

@dynamic privateKey;
@dynamic toAddress;
@dynamic amount;

typedef struct EasyTransferByPrivateMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *privateKey;
  NSData *toAddress;
  int64_t amount;
} EasyTransferByPrivateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "privateKey",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferByPrivateMessage_FieldNumber_PrivateKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EasyTransferByPrivateMessage__storage_, privateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferByPrivateMessage_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EasyTransferByPrivateMessage__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferByPrivateMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EasyTransferByPrivateMessage__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EasyTransferByPrivateMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EasyTransferByPrivateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EasyTransferAssetByPrivateMessage

@implementation EasyTransferAssetByPrivateMessage

@dynamic privateKey;
@dynamic toAddress;
@dynamic assetId;
@dynamic amount;

typedef struct EasyTransferAssetByPrivateMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *privateKey;
  NSData *toAddress;
  NSString *assetId;
  int64_t amount;
} EasyTransferAssetByPrivateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "privateKey",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetByPrivateMessage_FieldNumber_PrivateKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EasyTransferAssetByPrivateMessage__storage_, privateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetByPrivateMessage_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EasyTransferAssetByPrivateMessage__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetByPrivateMessage_FieldNumber_AssetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EasyTransferAssetByPrivateMessage__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferAssetByPrivateMessage_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EasyTransferAssetByPrivateMessage__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EasyTransferAssetByPrivateMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EasyTransferAssetByPrivateMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\n\000\002\t\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EasyTransferResponse

@implementation EasyTransferResponse

@dynamic hasTransaction, transaction;
@dynamic hasResult, result;
@dynamic txid;

typedef struct EasyTransferResponse__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transaction;
  Return *result;
  NSData *txid;
} EasyTransferResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = EasyTransferResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EasyTransferResponse__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(Return),
        .number = EasyTransferResponse_FieldNumber_Result,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EasyTransferResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = EasyTransferResponse_FieldNumber_Txid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EasyTransferResponse__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EasyTransferResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EasyTransferResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressPrKeyPairMessage

@implementation AddressPrKeyPairMessage

@dynamic address;
@dynamic privateKey;

typedef struct AddressPrKeyPairMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *privateKey;
} AddressPrKeyPairMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = AddressPrKeyPairMessage_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressPrKeyPairMessage__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "privateKey",
        .dataTypeSpecific.clazz = Nil,
        .number = AddressPrKeyPairMessage_FieldNumber_PrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressPrKeyPairMessage__storage_, privateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressPrKeyPairMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressPrKeyPairMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionExtention

@implementation TransactionExtention

@dynamic hasTransaction, transaction;
@dynamic txid;
@dynamic constantResultArray, constantResultArray_Count;
@dynamic hasResult, result;

typedef struct TransactionExtention__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transaction;
  NSData *txid;
  NSMutableArray *constantResultArray;
  Return *result;
} TransactionExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = TransactionExtention_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionExtention__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionExtention_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionExtention__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "constantResultArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionExtention_FieldNumber_ConstantResultArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionExtention__storage_, constantResultArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(Return),
        .number = TransactionExtention_FieldNumber_Result,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionExtention__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionExtention class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockExtention

@implementation BlockExtention

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;
@dynamic blockid;

typedef struct BlockExtention__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
  BlockHeader *blockHeader;
  NSData *blockid;
} BlockExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
        .number = BlockExtention_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockExtention__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeader",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockHeader),
        .number = BlockExtention_FieldNumber_BlockHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockExtention__storage_, blockHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockid",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockExtention_FieldNumber_Blockid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockExtention__storage_, blockid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockExtention class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockListExtention

@implementation BlockListExtention

@dynamic blockArray, blockArray_Count;

typedef struct BlockListExtention__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockArray;
} BlockListExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockExtention),
        .number = BlockListExtention_FieldNumber_BlockArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockListExtention__storage_, blockArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockListExtention class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockListExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionListExtention

@implementation TransactionListExtention

@dynamic transactionArray, transactionArray_Count;

typedef struct TransactionListExtention__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionArray;
} TransactionListExtention__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
        .number = TransactionListExtention_FieldNumber_TransactionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionListExtention__storage_, transactionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionListExtention class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionListExtention__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockIncrementalMerkleTree

@implementation BlockIncrementalMerkleTree

@dynamic number;
@dynamic hasMerkleTree, merkleTree;

typedef struct BlockIncrementalMerkleTree__storage_ {
  uint32_t _has_storage_[1];
  IncrementalMerkleTree *merkleTree;
  int64_t number;
} BlockIncrementalMerkleTree__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockIncrementalMerkleTree_FieldNumber_Number,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockIncrementalMerkleTree__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "merkleTree",
        .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleTree),
        .number = BlockIncrementalMerkleTree_FieldNumber_MerkleTree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockIncrementalMerkleTree__storage_, merkleTree),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockIncrementalMerkleTree class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockIncrementalMerkleTree__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionSignWeight

@implementation TransactionSignWeight

@dynamic hasPermission, permission;
@dynamic approvedListArray, approvedListArray_Count;
@dynamic currentWeight;
@dynamic hasResult, result;
@dynamic hasTransaction, transaction;

typedef struct TransactionSignWeight__storage_ {
  uint32_t _has_storage_[1];
  Permission *permission;
  NSMutableArray *approvedListArray;
  TransactionSignWeight_Result *result;
  TransactionExtention *transaction;
  int64_t currentWeight;
} TransactionSignWeight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "permission",
        .dataTypeSpecific.clazz = GPBObjCClass(Permission),
        .number = TransactionSignWeight_FieldNumber_Permission,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, permission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "approvedListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionSignWeight_FieldNumber_ApprovedListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, approvedListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "currentWeight",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionSignWeight_FieldNumber_CurrentWeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, currentWeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionSignWeight_Result),
        .number = TransactionSignWeight_FieldNumber_Result,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
        .number = TransactionSignWeight_FieldNumber_Transaction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionSignWeight__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionSignWeight class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSignWeight__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionSignWeight_Result

@implementation TransactionSignWeight_Result

@dynamic code;
@dynamic message;

typedef struct TransactionSignWeight_Result__storage_ {
  uint32_t _has_storage_[1];
  TransactionSignWeight_Result_response_code code;
  NSString *message;
} TransactionSignWeight_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = TransactionSignWeight_Result_response_code_EnumDescriptor,
        .number = TransactionSignWeight_Result_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionSignWeight_Result__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionSignWeight_Result_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionSignWeight_Result__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionSignWeight_Result class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSignWeight_Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionSignWeight)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransactionSignWeight_Result_Code_RawValue(TransactionSignWeight_Result *message) {
  GPBDescriptor *descriptor = [TransactionSignWeight_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionSignWeight_Result_FieldNumber_Code];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionSignWeight_Result_Code_RawValue(TransactionSignWeight_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [TransactionSignWeight_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionSignWeight_Result_FieldNumber_Code];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum TransactionSignWeight_Result_response_code

GPBEnumDescriptor *TransactionSignWeight_Result_response_code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EnoughPermission\000NotEnoughPermission\000Sig"
        "natureFormatError\000ComputeAddressError\000Pe"
        "rmissionError\000OtherError\000";
    static const int32_t values[] = {
        TransactionSignWeight_Result_response_code_EnoughPermission,
        TransactionSignWeight_Result_response_code_NotEnoughPermission,
        TransactionSignWeight_Result_response_code_SignatureFormatError,
        TransactionSignWeight_Result_response_code_ComputeAddressError,
        TransactionSignWeight_Result_response_code_PermissionError,
        TransactionSignWeight_Result_response_code_OtherError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionSignWeight_Result_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionSignWeight_Result_response_code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionSignWeight_Result_response_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionSignWeight_Result_response_code_EnoughPermission:
    case TransactionSignWeight_Result_response_code_NotEnoughPermission:
    case TransactionSignWeight_Result_response_code_SignatureFormatError:
    case TransactionSignWeight_Result_response_code_ComputeAddressError:
    case TransactionSignWeight_Result_response_code_PermissionError:
    case TransactionSignWeight_Result_response_code_OtherError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransactionApprovedList

@implementation TransactionApprovedList

@dynamic approvedListArray, approvedListArray_Count;
@dynamic hasResult, result;
@dynamic hasTransaction, transaction;

typedef struct TransactionApprovedList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *approvedListArray;
  TransactionApprovedList_Result *result;
  TransactionExtention *transaction;
} TransactionApprovedList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "approvedListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionApprovedList_FieldNumber_ApprovedListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, approvedListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionApprovedList_Result),
        .number = TransactionApprovedList_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionExtention),
        .number = TransactionApprovedList_FieldNumber_Transaction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionApprovedList__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionApprovedList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionApprovedList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionApprovedList_Result

@implementation TransactionApprovedList_Result

@dynamic code;
@dynamic message;

typedef struct TransactionApprovedList_Result__storage_ {
  uint32_t _has_storage_[1];
  TransactionApprovedList_Result_response_code code;
  NSString *message;
} TransactionApprovedList_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = TransactionApprovedList_Result_response_code_EnumDescriptor,
        .number = TransactionApprovedList_Result_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionApprovedList_Result__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionApprovedList_Result_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionApprovedList_Result__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionApprovedList_Result class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionApprovedList_Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionApprovedList)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransactionApprovedList_Result_Code_RawValue(TransactionApprovedList_Result *message) {
  GPBDescriptor *descriptor = [TransactionApprovedList_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionApprovedList_Result_FieldNumber_Code];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionApprovedList_Result_Code_RawValue(TransactionApprovedList_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [TransactionApprovedList_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionApprovedList_Result_FieldNumber_Code];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum TransactionApprovedList_Result_response_code

GPBEnumDescriptor *TransactionApprovedList_Result_response_code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000SignatureFormatError\000ComputeAddr"
        "essError\000OtherError\000";
    static const int32_t values[] = {
        TransactionApprovedList_Result_response_code_Success,
        TransactionApprovedList_Result_response_code_SignatureFormatError,
        TransactionApprovedList_Result_response_code_ComputeAddressError,
        TransactionApprovedList_Result_response_code_OtherError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionApprovedList_Result_response_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionApprovedList_Result_response_code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionApprovedList_Result_response_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionApprovedList_Result_response_code_Success:
    case TransactionApprovedList_Result_response_code_SignatureFormatError:
    case TransactionApprovedList_Result_response_code_ComputeAddressError:
    case TransactionApprovedList_Result_response_code_OtherError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - IvkDecryptParameters

@implementation IvkDecryptParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ivk;

typedef struct IvkDecryptParameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ivk;
  int64_t startBlockIndex;
  int64_t endBlockIndex;
} IvkDecryptParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptParameters_FieldNumber_StartBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, startBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptParameters_FieldNumber_EndBlockIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, endBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptParameters_FieldNumber_Ivk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IvkDecryptParameters__storage_, ivk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IvkDecryptParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IvkDecryptAndMarkParameters

@implementation IvkDecryptAndMarkParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ivk;
@dynamic ak;
@dynamic nk;

typedef struct IvkDecryptAndMarkParameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ak;
  NSData *nk;
  NSData *ivk;
  int64_t startBlockIndex;
  int64_t endBlockIndex;
} IvkDecryptAndMarkParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptAndMarkParameters_FieldNumber_StartBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, startBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptAndMarkParameters_FieldNumber_EndBlockIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, endBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptAndMarkParameters_FieldNumber_Ak,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptAndMarkParameters_FieldNumber_Nk,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptAndMarkParameters_FieldNumber_Ivk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IvkDecryptAndMarkParameters__storage_, ivk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IvkDecryptAndMarkParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptAndMarkParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OvkDecryptParameters

@implementation OvkDecryptParameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ovk;

typedef struct OvkDecryptParameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ovk;
  int64_t startBlockIndex;
  int64_t endBlockIndex;
} OvkDecryptParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptParameters_FieldNumber_StartBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, startBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptParameters_FieldNumber_EndBlockIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, endBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptParameters_FieldNumber_Ovk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OvkDecryptParameters__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OvkDecryptParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OvkDecryptParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotes

@implementation DecryptNotes

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *noteTxsArray;
} DecryptNotes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "noteTxsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotes_NoteTx),
        .number = DecryptNotes_FieldNumber_NoteTxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DecryptNotes__storage_, noteTxsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotes class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotes_NoteTx

@implementation DecryptNotes_NoteTx

@dynamic hasNote, note;
@dynamic txid;
@dynamic index;

typedef struct DecryptNotes_NoteTx__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  Note *note;
  NSData *txid;
} DecryptNotes_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = DecryptNotes_NoteTx_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotes_NoteTx_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotes_NoteTx_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DecryptNotes_NoteTx__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotes_NoteTx class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotes_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotesMarked

@implementation DecryptNotesMarked

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotesMarked__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *noteTxsArray;
} DecryptNotesMarked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "noteTxsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotesMarked_NoteTx),
        .number = DecryptNotesMarked_FieldNumber_NoteTxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DecryptNotesMarked__storage_, noteTxsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotesMarked class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesMarked__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotesMarked_NoteTx

@implementation DecryptNotesMarked_NoteTx

@dynamic hasNote, note;
@dynamic txid;
@dynamic index;
@dynamic isSpend;

typedef struct DecryptNotesMarked_NoteTx__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  Note *note;
  NSData *txid;
} DecryptNotesMarked_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = DecryptNotesMarked_NoteTx_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesMarked_NoteTx_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesMarked_NoteTx_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DecryptNotesMarked_NoteTx__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isSpend",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesMarked_NoteTx_FieldNumber_IsSpend,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotesMarked_NoteTx class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesMarked_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotesMarked)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Note

@implementation Note

@dynamic value;
@dynamic paymentAddress;
@dynamic rcm;
@dynamic memo;

typedef struct Note__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentAddress;
  NSData *rcm;
  NSData *memo;
  int64_t value;
} Note__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Note_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Note__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Note_FieldNumber_PaymentAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Note__storage_, paymentAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rcm",
        .dataTypeSpecific.clazz = Nil,
        .number = Note_FieldNumber_Rcm,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Note__storage_, rcm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "memo",
        .dataTypeSpecific.clazz = Nil,
        .number = Note_FieldNumber_Memo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Note__storage_, memo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Note class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Note__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpendNote

@implementation SpendNote

@dynamic hasNote, note;
@dynamic alpha;
@dynamic hasVoucher, voucher;
@dynamic path;

typedef struct SpendNote__storage_ {
  uint32_t _has_storage_[1];
  Note *note;
  NSData *alpha;
  IncrementalMerkleVoucher *voucher;
  NSData *path;
} SpendNote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = SpendNote_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpendNote__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNote_FieldNumber_Alpha,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpendNote__storage_, alpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voucher",
        .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleVoucher),
        .number = SpendNote_FieldNumber_Voucher,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpendNote__storage_, voucher),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNote_FieldNumber_Path,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SpendNote__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpendNote class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendNote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiveNote

@implementation ReceiveNote

@dynamic hasNote, note;

typedef struct ReceiveNote__storage_ {
  uint32_t _has_storage_[1];
  Note *note;
} ReceiveNote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = ReceiveNote_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiveNote__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiveNote class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveNote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrivateParameters

@implementation PrivateParameters

@dynamic transparentFromAddress;
@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic timeout;

typedef struct PrivateParameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *transparentFromAddress;
  NSData *ask;
  NSData *nsk;
  NSData *ovk;
  NSMutableArray *shieldedSpendsArray;
  NSMutableArray *shieldedReceivesArray;
  NSData *transparentToAddress;
  int64_t fromAmount;
  int64_t toAmount;
  int64_t timeout;
} PrivateParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transparentFromAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_TransparentFromAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, transparentFromAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ask",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_Ask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_Nsk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_Ovk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_FromAmount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, fromAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedSpendsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpendNote),
        .number = PrivateParameters_FieldNumber_ShieldedSpendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, shieldedSpendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shieldedReceivesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
        .number = PrivateParameters_FieldNumber_ShieldedReceivesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, shieldedReceivesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_TransparentToAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_ToAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, toAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParameters_FieldNumber_Timeout,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PrivateParameters__storage_, timeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrivateParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrivateParametersWithoutAsk

@implementation PrivateParametersWithoutAsk

@dynamic transparentFromAddress;
@dynamic ak;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic timeout;

typedef struct PrivateParametersWithoutAsk__storage_ {
  uint32_t _has_storage_[1];
  NSData *transparentFromAddress;
  NSData *ak;
  NSData *nsk;
  NSData *ovk;
  NSMutableArray *shieldedSpendsArray;
  NSMutableArray *shieldedReceivesArray;
  NSData *transparentToAddress;
  int64_t fromAmount;
  int64_t toAmount;
  int64_t timeout;
} PrivateParametersWithoutAsk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transparentFromAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_TransparentFromAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, transparentFromAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_Ak,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_Nsk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_Ovk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_FromAmount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, fromAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedSpendsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpendNote),
        .number = PrivateParametersWithoutAsk_FieldNumber_ShieldedSpendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, shieldedSpendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shieldedReceivesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
        .number = PrivateParametersWithoutAsk_FieldNumber_ShieldedReceivesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, shieldedReceivesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_TransparentToAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_ToAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, toAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateParametersWithoutAsk_FieldNumber_Timeout,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PrivateParametersWithoutAsk__storage_, timeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrivateParametersWithoutAsk class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateParametersWithoutAsk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpendAuthSigParameters

@implementation SpendAuthSigParameters

@dynamic ask;
@dynamic txHash;
@dynamic alpha;

typedef struct SpendAuthSigParameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ask;
  NSData *txHash;
  NSData *alpha;
} SpendAuthSigParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ask",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendAuthSigParameters_FieldNumber_Ask,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendAuthSigParameters_FieldNumber_TxHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, txHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendAuthSigParameters_FieldNumber_Alpha,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpendAuthSigParameters__storage_, alpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpendAuthSigParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendAuthSigParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NfParameters

@implementation NfParameters

@dynamic hasNote, note;
@dynamic hasVoucher, voucher;
@dynamic ak;
@dynamic nk;

typedef struct NfParameters__storage_ {
  uint32_t _has_storage_[1];
  Note *note;
  IncrementalMerkleVoucher *voucher;
  NSData *ak;
  NSData *nk;
} NfParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = NfParameters_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NfParameters__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voucher",
        .dataTypeSpecific.clazz = GPBObjCClass(IncrementalMerkleVoucher),
        .number = NfParameters_FieldNumber_Voucher,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NfParameters__storage_, voucher),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = NfParameters_FieldNumber_Ak,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NfParameters__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = NfParameters_FieldNumber_Nk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NfParameters__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NfParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NfParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExpandedSpendingKeyMessage

@implementation ExpandedSpendingKeyMessage

@dynamic ask;
@dynamic nsk;
@dynamic ovk;

typedef struct ExpandedSpendingKeyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *ask;
  NSData *nsk;
  NSData *ovk;
} ExpandedSpendingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ask",
        .dataTypeSpecific.clazz = Nil,
        .number = ExpandedSpendingKeyMessage_FieldNumber_Ask,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = ExpandedSpendingKeyMessage_FieldNumber_Nsk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = ExpandedSpendingKeyMessage_FieldNumber_Ovk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExpandedSpendingKeyMessage__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExpandedSpendingKeyMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExpandedSpendingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ViewingKeyMessage

@implementation ViewingKeyMessage

@dynamic ak;
@dynamic nk;

typedef struct ViewingKeyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *ak;
  NSData *nk;
} ViewingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = ViewingKeyMessage_FieldNumber_Ak,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ViewingKeyMessage__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = ViewingKeyMessage_FieldNumber_Nk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ViewingKeyMessage__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ViewingKeyMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ViewingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IncomingViewingKeyMessage

@implementation IncomingViewingKeyMessage

@dynamic ivk;

typedef struct IncomingViewingKeyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *ivk;
} IncomingViewingKeyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = Nil,
        .number = IncomingViewingKeyMessage_FieldNumber_Ivk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IncomingViewingKeyMessage__storage_, ivk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IncomingViewingKeyMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncomingViewingKeyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DiversifierMessage

@implementation DiversifierMessage

@dynamic d;

typedef struct DiversifierMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *d;
} DiversifierMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = DiversifierMessage_FieldNumber_D,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DiversifierMessage__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DiversifierMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DiversifierMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IncomingViewingKeyDiversifierMessage

@implementation IncomingViewingKeyDiversifierMessage

@dynamic hasIvk, ivk;
@dynamic hasD, d;

typedef struct IncomingViewingKeyDiversifierMessage__storage_ {
  uint32_t _has_storage_[1];
  IncomingViewingKeyMessage *ivk;
  DiversifierMessage *d;
} IncomingViewingKeyDiversifierMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = GPBObjCClass(IncomingViewingKeyMessage),
        .number = IncomingViewingKeyDiversifierMessage_FieldNumber_Ivk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IncomingViewingKeyDiversifierMessage__storage_, ivk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "d",
        .dataTypeSpecific.clazz = GPBObjCClass(DiversifierMessage),
        .number = IncomingViewingKeyDiversifierMessage_FieldNumber_D,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IncomingViewingKeyDiversifierMessage__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IncomingViewingKeyDiversifierMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IncomingViewingKeyDiversifierMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentAddressMessage

@implementation PaymentAddressMessage

@dynamic hasD, d;
@dynamic pkD;
@dynamic paymentAddress;

typedef struct PaymentAddressMessage__storage_ {
  uint32_t _has_storage_[1];
  DiversifierMessage *d;
  NSData *pkD;
  NSString *paymentAddress;
} PaymentAddressMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "d",
        .dataTypeSpecific.clazz = GPBObjCClass(DiversifierMessage),
        .number = PaymentAddressMessage_FieldNumber_D,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pkD",
        .dataTypeSpecific.clazz = Nil,
        .number = PaymentAddressMessage_FieldNumber_PkD,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, pkD),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PaymentAddressMessage_FieldNumber_PaymentAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentAddressMessage__storage_, paymentAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentAddressMessage class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentAddressMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShieldedAddressInfo

@implementation ShieldedAddressInfo

@dynamic sk;
@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic ak;
@dynamic nk;
@dynamic ivk;
@dynamic d;
@dynamic pkD;
@dynamic paymentAddress;

typedef struct ShieldedAddressInfo__storage_ {
  uint32_t _has_storage_[1];
  NSData *sk;
  NSData *ask;
  NSData *nsk;
  NSData *ovk;
  NSData *ak;
  NSData *nk;
  NSData *ivk;
  NSData *d;
  NSData *pkD;
  NSString *paymentAddress;
} ShieldedAddressInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sk",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Sk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, sk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ask",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Ask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Nsk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Ovk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Ak,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Nk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_Ivk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, ivk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_D,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pkD",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_PkD,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, pkD),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedAddressInfo_FieldNumber_PaymentAddress,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ShieldedAddressInfo__storage_, paymentAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShieldedAddressInfo class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedAddressInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NoteParameters

@implementation NoteParameters

@dynamic ak;
@dynamic nk;
@dynamic hasNote, note;
@dynamic txid;
@dynamic index;

typedef struct NoteParameters__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  NSData *ak;
  NSData *nk;
  Note *note;
  NSData *txid;
} NoteParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = NoteParameters_FieldNumber_Ak,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NoteParameters__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = NoteParameters_FieldNumber_Nk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NoteParameters__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = NoteParameters_FieldNumber_Note,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NoteParameters__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = NoteParameters_FieldNumber_Txid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NoteParameters__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = NoteParameters_FieldNumber_Index,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NoteParameters__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoteParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NoteParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpendResult

@implementation SpendResult

@dynamic result;
@dynamic message;

typedef struct SpendResult__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} SpendResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendResult_FieldNumber_Result,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendResult_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpendResult__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpendResult class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionInfoList

@implementation TransactionInfoList

@dynamic transactionInfoArray, transactionInfoArray_Count;

typedef struct TransactionInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionInfoArray;
} TransactionInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionInfoArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionInfo),
        .number = TransactionInfoList_FieldNumber_TransactionInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfoList__storage_, transactionInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionInfoList class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfoList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000transactionInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpendNoteVRC20

@implementation SpendNoteVRC20

@dynamic hasNote, note;
@dynamic alpha;
@dynamic root;
@dynamic path;
@dynamic pos;

typedef struct SpendNoteVRC20__storage_ {
  uint32_t _has_storage_[1];
  Note *note;
  NSData *alpha;
  NSData *root;
  NSData *path;
  int64_t pos;
} SpendNoteVRC20__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = SpendNoteVRC20_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpendNoteVRC20__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNoteVRC20_FieldNumber_Alpha,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpendNoteVRC20__storage_, alpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "root",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNoteVRC20_FieldNumber_Root,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpendNoteVRC20__storage_, root),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNoteVRC20_FieldNumber_Path,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SpendNoteVRC20__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pos",
        .dataTypeSpecific.clazz = Nil,
        .number = SpendNoteVRC20_FieldNumber_Pos,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SpendNoteVRC20__storage_, pos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpendNoteVRC20 class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpendNoteVRC20__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrivateShieldedVRC20Parameters

@implementation PrivateShieldedVRC20Parameters

@dynamic ask;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic shieldedVrc20ContractAddress;

typedef struct PrivateShieldedVRC20Parameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ask;
  NSData *nsk;
  NSData *ovk;
  NSString *fromAmount;
  NSMutableArray *shieldedSpendsArray;
  NSMutableArray *shieldedReceivesArray;
  NSData *transparentToAddress;
  NSString *toAmount;
  NSData *shieldedVrc20ContractAddress;
} PrivateShieldedVRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ask",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_Ask,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, ask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_Nsk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_Ovk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_FromAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, fromAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shieldedSpendsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpendNoteVRC20),
        .number = PrivateShieldedVRC20Parameters_FieldNumber_ShieldedSpendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, shieldedSpendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shieldedReceivesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
        .number = PrivateShieldedVRC20Parameters_FieldNumber_ShieldedReceivesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, shieldedReceivesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_TransparentToAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_ToAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, toAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shieldedVrc20ContractAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20Parameters_FieldNumber_ShieldedVrc20ContractAddress,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20Parameters__storage_, shieldedVrc20ContractAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrivateShieldedVRC20Parameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateShieldedVRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\010\343\002\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrivateShieldedVRC20ParametersWithoutAsk

@implementation PrivateShieldedVRC20ParametersWithoutAsk

@dynamic ak;
@dynamic nsk;
@dynamic ovk;
@dynamic fromAmount;
@dynamic shieldedSpendsArray, shieldedSpendsArray_Count;
@dynamic shieldedReceivesArray, shieldedReceivesArray_Count;
@dynamic transparentToAddress;
@dynamic toAmount;
@dynamic shieldedVrc20ContractAddress;

typedef struct PrivateShieldedVRC20ParametersWithoutAsk__storage_ {
  uint32_t _has_storage_[1];
  NSData *ak;
  NSData *nsk;
  NSData *ovk;
  NSString *fromAmount;
  NSMutableArray *shieldedSpendsArray;
  NSMutableArray *shieldedReceivesArray;
  NSData *transparentToAddress;
  NSString *toAmount;
  NSData *shieldedVrc20ContractAddress;
} PrivateShieldedVRC20ParametersWithoutAsk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_Ak,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nsk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_Nsk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, nsk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_Ovk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_FromAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, fromAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shieldedSpendsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpendNoteVRC20),
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_ShieldedSpendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, shieldedSpendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shieldedReceivesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReceiveNote),
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_ShieldedReceivesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, shieldedReceivesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_TransparentToAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_ToAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, toAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shieldedVrc20ContractAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivateShieldedVRC20ParametersWithoutAsk_FieldNumber_ShieldedVrc20ContractAddress,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PrivateShieldedVRC20ParametersWithoutAsk__storage_, shieldedVrc20ContractAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrivateShieldedVRC20ParametersWithoutAsk class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivateShieldedVRC20ParametersWithoutAsk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\010\343\002\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShieldedVRC20Parameters

@implementation ShieldedVRC20Parameters

@dynamic spendDescriptionArray, spendDescriptionArray_Count;
@dynamic receiveDescriptionArray, receiveDescriptionArray_Count;
@dynamic bindingSignature;
@dynamic messageHash;
@dynamic triggerContractInput;
@dynamic parameterType;

typedef struct ShieldedVRC20Parameters__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *spendDescriptionArray;
  NSMutableArray *receiveDescriptionArray;
  NSData *bindingSignature;
  NSData *messageHash;
  NSString *triggerContractInput;
  NSString *parameterType;
} ShieldedVRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spendDescriptionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SpendDescription),
        .number = ShieldedVRC20Parameters_FieldNumber_SpendDescriptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, spendDescriptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiveDescriptionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReceiveDescription),
        .number = ShieldedVRC20Parameters_FieldNumber_ReceiveDescriptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, receiveDescriptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindingSignature",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20Parameters_FieldNumber_BindingSignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, bindingSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "messageHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20Parameters_FieldNumber_MessageHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, messageHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "triggerContractInput",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20Parameters_FieldNumber_TriggerContractInput,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, triggerContractInput),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parameterType",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20Parameters_FieldNumber_ParameterType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShieldedVRC20Parameters__storage_, parameterType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShieldedVRC20Parameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedVRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IvkDecryptVRC20Parameters

@implementation IvkDecryptVRC20Parameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic shieldedVrc20ContractAddress;
@dynamic ivk;
@dynamic ak;
@dynamic nk;
@dynamic eventsArray, eventsArray_Count;

typedef struct IvkDecryptVRC20Parameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *shieldedVrc20ContractAddress;
  NSData *ivk;
  NSData *ak;
  NSData *nk;
  NSMutableArray *eventsArray;
  int64_t startBlockIndex;
  int64_t endBlockIndex;
} IvkDecryptVRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_StartBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, startBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_EndBlockIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, endBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedVrc20ContractAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_ShieldedVrc20ContractAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, shieldedVrc20ContractAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ivk",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_Ivk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, ivk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_Ak,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_Nk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = IvkDecryptVRC20Parameters_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IvkDecryptVRC20Parameters__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IvkDecryptVRC20Parameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IvkDecryptVRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\010\343\002\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OvkDecryptVRC20Parameters

@implementation OvkDecryptVRC20Parameters

@dynamic startBlockIndex;
@dynamic endBlockIndex;
@dynamic ovk;
@dynamic shieldedVrc20ContractAddress;
@dynamic eventsArray, eventsArray_Count;

typedef struct OvkDecryptVRC20Parameters__storage_ {
  uint32_t _has_storage_[1];
  NSData *ovk;
  NSData *shieldedVrc20ContractAddress;
  NSMutableArray *eventsArray;
  int64_t startBlockIndex;
  int64_t endBlockIndex;
} OvkDecryptVRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptVRC20Parameters_FieldNumber_StartBlockIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OvkDecryptVRC20Parameters__storage_, startBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endBlockIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptVRC20Parameters_FieldNumber_EndBlockIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OvkDecryptVRC20Parameters__storage_, endBlockIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ovk",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptVRC20Parameters_FieldNumber_Ovk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OvkDecryptVRC20Parameters__storage_, ovk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "shieldedVrc20ContractAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptVRC20Parameters_FieldNumber_ShieldedVrc20ContractAddress,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OvkDecryptVRC20Parameters__storage_, shieldedVrc20ContractAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = OvkDecryptVRC20Parameters_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OvkDecryptVRC20Parameters__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OvkDecryptVRC20Parameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OvkDecryptVRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\343\002\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotesVRC20

@implementation DecryptNotesVRC20

@dynamic noteTxsArray, noteTxsArray_Count;

typedef struct DecryptNotesVRC20__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *noteTxsArray;
} DecryptNotesVRC20__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "noteTxsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecryptNotesVRC20_NoteTx),
        .number = DecryptNotesVRC20_FieldNumber_NoteTxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20__storage_, noteTxsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotesVRC20 class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesVRC20__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000noteTxs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecryptNotesVRC20_NoteTx

@implementation DecryptNotesVRC20_NoteTx

@dynamic hasNote, note;
@dynamic position;
@dynamic isSpent;
@dynamic txid;
@dynamic index;
@dynamic toAmount;
@dynamic transparentToAddress;

typedef struct DecryptNotesVRC20_NoteTx__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  Note *note;
  NSData *txid;
  NSString *toAmount;
  NSData *transparentToAddress;
  int64_t position;
} DecryptNotesVRC20_NoteTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_IsSpent,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "txid",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_Txid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, txid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_Index,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_ToAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, toAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DecryptNotesVRC20_NoteTx_FieldNumber_TransparentToAddress,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DecryptNotesVRC20_NoteTx__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecryptNotesVRC20_NoteTx class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecryptNotesVRC20_NoteTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DecryptNotesVRC20)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NfVRC20Parameters

@implementation NfVRC20Parameters

@dynamic hasNote, note;
@dynamic ak;
@dynamic nk;
@dynamic position;
@dynamic shieldedVrc20ContractAddress;

typedef struct NfVRC20Parameters__storage_ {
  uint32_t _has_storage_[1];
  Note *note;
  NSData *ak;
  NSData *nk;
  NSData *shieldedVrc20ContractAddress;
  int64_t position;
} NfVRC20Parameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "note",
        .dataTypeSpecific.clazz = GPBObjCClass(Note),
        .number = NfVRC20Parameters_FieldNumber_Note,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NfVRC20Parameters__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ak",
        .dataTypeSpecific.clazz = Nil,
        .number = NfVRC20Parameters_FieldNumber_Ak,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NfVRC20Parameters__storage_, ak),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nk",
        .dataTypeSpecific.clazz = Nil,
        .number = NfVRC20Parameters_FieldNumber_Nk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NfVRC20Parameters__storage_, nk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = Nil,
        .number = NfVRC20Parameters_FieldNumber_Position,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NfVRC20Parameters__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedVrc20ContractAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = NfVRC20Parameters_FieldNumber_ShieldedVrc20ContractAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NfVRC20Parameters__storage_, shieldedVrc20ContractAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NfVRC20Parameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NfVRC20Parameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\010\343\002\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NullifierResult

@implementation NullifierResult

@dynamic isSpent;

typedef struct NullifierResult__storage_ {
  uint32_t _has_storage_[1];
} NullifierResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = NullifierResult_FieldNumber_IsSpent,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NullifierResult class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NullifierResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShieldedVRC20TriggerContractParameters

@implementation ShieldedVRC20TriggerContractParameters

@dynamic hasShieldedVrc20Parameters, shieldedVrc20Parameters;
@dynamic spendAuthoritySignatureArray, spendAuthoritySignatureArray_Count;
@dynamic amount;
@dynamic transparentToAddress;

typedef struct ShieldedVRC20TriggerContractParameters__storage_ {
  uint32_t _has_storage_[1];
  ShieldedVRC20Parameters *shieldedVrc20Parameters;
  NSMutableArray *spendAuthoritySignatureArray;
  NSString *amount;
  NSData *transparentToAddress;
} ShieldedVRC20TriggerContractParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shieldedVrc20Parameters",
        .dataTypeSpecific.clazz = GPBObjCClass(ShieldedVRC20Parameters),
        .number = ShieldedVRC20TriggerContractParameters_FieldNumber_ShieldedVrc20Parameters,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShieldedVRC20TriggerContractParameters__storage_, shieldedVrc20Parameters),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spendAuthoritySignatureArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BytesMessage),
        .number = ShieldedVRC20TriggerContractParameters_FieldNumber_SpendAuthoritySignatureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShieldedVRC20TriggerContractParameters__storage_, spendAuthoritySignatureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20TriggerContractParameters_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShieldedVRC20TriggerContractParameters__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transparentToAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = ShieldedVRC20TriggerContractParameters_FieldNumber_TransparentToAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShieldedVRC20TriggerContractParameters__storage_, transparentToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShieldedVRC20TriggerContractParameters class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShieldedVRC20TriggerContractParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\343\002\212\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
