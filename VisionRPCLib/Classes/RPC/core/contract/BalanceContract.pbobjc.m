// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/contract/balance_contract.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "BalanceContract.pbobjc.h"
#import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AccountIdentifier);
GPBObjCClassDeclaration(BlockBalanceTrace);
GPBObjCClassDeclaration(BlockBalanceTrace_BlockIdentifier);
GPBObjCClassDeclaration(TransactionBalanceTrace);
GPBObjCClassDeclaration(TransactionBalanceTrace_Operation);

#pragma mark - BalanceContractRoot

@implementation BalanceContractRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - BalanceContractRoot_FileDescriptor

static GPBFileDescriptor *BalanceContractRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - FreezeBalanceContract

@implementation FreezeBalanceContract

@dynamic ownerAddress;
@dynamic frozenBalance;
@dynamic frozenDuration;
@dynamic resource;
@dynamic receiverAddress;
@dynamic parentAddress;

typedef struct FreezeBalanceContract__storage_ {
  uint32_t _has_storage_[1];
  ResourceCode resource;
  NSData *ownerAddress;
  NSData *receiverAddress;
  NSData *parentAddress;
  int64_t frozenBalance;
  int64_t frozenDuration;
} FreezeBalanceContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = FreezeBalanceContract_FieldNumber_OwnerAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, ownerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frozenBalance",
        .dataTypeSpecific.clazz = Nil,
        .number = FreezeBalanceContract_FieldNumber_FrozenBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, frozenBalance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = FreezeBalanceContract_FieldNumber_FrozenDuration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, frozenDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "resource",
        .dataTypeSpecific.enumDescFunc = ResourceCode_EnumDescriptor,
        .number = FreezeBalanceContract_FieldNumber_Resource,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, resource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "receiverAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = FreezeBalanceContract_FieldNumber_ReceiverAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, receiverAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parentAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = FreezeBalanceContract_FieldNumber_ParentAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FreezeBalanceContract__storage_, parentAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FreezeBalanceContract class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FreezeBalanceContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FreezeBalanceContract_Resource_RawValue(FreezeBalanceContract *message) {
  GPBDescriptor *descriptor = [FreezeBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FreezeBalanceContract_FieldNumber_Resource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetFreezeBalanceContract_Resource_RawValue(FreezeBalanceContract *message, int32_t value) {
  GPBDescriptor *descriptor = [FreezeBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FreezeBalanceContract_FieldNumber_Resource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UnfreezeBalanceContract

@implementation UnfreezeBalanceContract

@dynamic ownerAddress;
@dynamic resource;
@dynamic receiverAddress;

typedef struct UnfreezeBalanceContract__storage_ {
  uint32_t _has_storage_[1];
  ResourceCode resource;
  NSData *ownerAddress;
  NSData *receiverAddress;
} UnfreezeBalanceContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = UnfreezeBalanceContract_FieldNumber_OwnerAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnfreezeBalanceContract__storage_, ownerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "resource",
        .dataTypeSpecific.enumDescFunc = ResourceCode_EnumDescriptor,
        .number = UnfreezeBalanceContract_FieldNumber_Resource,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnfreezeBalanceContract__storage_, resource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "receiverAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = UnfreezeBalanceContract_FieldNumber_ReceiverAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnfreezeBalanceContract__storage_, receiverAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnfreezeBalanceContract class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnfreezeBalanceContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UnfreezeBalanceContract_Resource_RawValue(UnfreezeBalanceContract *message) {
  GPBDescriptor *descriptor = [UnfreezeBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnfreezeBalanceContract_FieldNumber_Resource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUnfreezeBalanceContract_Resource_RawValue(UnfreezeBalanceContract *message, int32_t value) {
  GPBDescriptor *descriptor = [UnfreezeBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UnfreezeBalanceContract_FieldNumber_Resource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - WithdrawBalanceContract

@implementation WithdrawBalanceContract

@dynamic ownerAddress;
@dynamic type;

typedef struct WithdrawBalanceContract__storage_ {
  uint32_t _has_storage_[1];
  WithdrawBalanceContract_WithdrawBalanceType type;
  NSData *ownerAddress;
} WithdrawBalanceContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = WithdrawBalanceContract_FieldNumber_OwnerAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WithdrawBalanceContract__storage_, ownerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = WithdrawBalanceContract_WithdrawBalanceType_EnumDescriptor,
        .number = WithdrawBalanceContract_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WithdrawBalanceContract__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WithdrawBalanceContract class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WithdrawBalanceContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t WithdrawBalanceContract_Type_RawValue(WithdrawBalanceContract *message) {
  GPBDescriptor *descriptor = [WithdrawBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:WithdrawBalanceContract_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetWithdrawBalanceContract_Type_RawValue(WithdrawBalanceContract *message, int32_t value) {
  GPBDescriptor *descriptor = [WithdrawBalanceContract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:WithdrawBalanceContract_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum WithdrawBalanceContract_WithdrawBalanceType

GPBEnumDescriptor *WithdrawBalanceContract_WithdrawBalanceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "All\000SpreadMint\000";
    static const int32_t values[] = {
        WithdrawBalanceContract_WithdrawBalanceType_All,
        WithdrawBalanceContract_WithdrawBalanceType_SpreadMint,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WithdrawBalanceContract_WithdrawBalanceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WithdrawBalanceContract_WithdrawBalanceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WithdrawBalanceContract_WithdrawBalanceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case WithdrawBalanceContract_WithdrawBalanceType_All:
    case WithdrawBalanceContract_WithdrawBalanceType_SpreadMint:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransferContract

@implementation TransferContract

@dynamic ownerAddress;
@dynamic toAddress;
@dynamic amount;
@dynamic type;
@dynamic rlpData;

typedef struct TransferContract__storage_ {
  uint32_t _has_storage_[1];
  NSData *ownerAddress;
  NSData *toAddress;
  NSData *rlpData;
  int64_t amount;
  int64_t type;
} TransferContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferContract_FieldNumber_OwnerAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferContract__storage_, ownerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferContract_FieldNumber_ToAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferContract__storage_, toAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferContract_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferContract__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferContract_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferContract__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rlpData",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferContract_FieldNumber_RlpData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransferContract__storage_, rlpData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferContract class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionBalanceTrace

@implementation TransactionBalanceTrace

@dynamic transactionIdentifier;
@dynamic operationArray, operationArray_Count;
@dynamic type;
@dynamic status;

typedef struct TransactionBalanceTrace__storage_ {
  uint32_t _has_storage_[1];
  NSData *transactionIdentifier;
  NSMutableArray *operationArray;
  NSString *type;
  NSString *status;
} TransactionBalanceTrace__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_FieldNumber_TransactionIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace__storage_, transactionIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "operationArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionBalanceTrace_Operation),
        .number = TransactionBalanceTrace_FieldNumber_OperationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace__storage_, operationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionBalanceTrace class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionBalanceTrace__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionBalanceTrace_Operation

@implementation TransactionBalanceTrace_Operation

@dynamic operationIdentifier;
@dynamic address;
@dynamic amount;

typedef struct TransactionBalanceTrace_Operation__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  int64_t operationIdentifier;
  int64_t amount;
} TransactionBalanceTrace_Operation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operationIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_Operation_FieldNumber_OperationIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace_Operation__storage_, operationIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_Operation_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace_Operation__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionBalanceTrace_Operation_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionBalanceTrace_Operation__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionBalanceTrace_Operation class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionBalanceTrace_Operation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TransactionBalanceTrace)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockBalanceTrace

@implementation BlockBalanceTrace

@dynamic hasBlockIdentifier, blockIdentifier;
@dynamic timestamp;
@dynamic transactionBalanceTraceArray, transactionBalanceTraceArray_Count;

typedef struct BlockBalanceTrace__storage_ {
  uint32_t _has_storage_[1];
  BlockBalanceTrace_BlockIdentifier *blockIdentifier;
  NSMutableArray *transactionBalanceTraceArray;
  int64_t timestamp;
} BlockBalanceTrace__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockIdentifier",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockBalanceTrace_BlockIdentifier),
        .number = BlockBalanceTrace_FieldNumber_BlockIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockBalanceTrace__storage_, blockIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockBalanceTrace_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockBalanceTrace__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "transactionBalanceTraceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionBalanceTrace),
        .number = BlockBalanceTrace_FieldNumber_TransactionBalanceTraceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockBalanceTrace__storage_, transactionBalanceTraceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockBalanceTrace class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockBalanceTrace__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockBalanceTrace_BlockIdentifier

@implementation BlockBalanceTrace_BlockIdentifier

@dynamic hash_p;
@dynamic number;

typedef struct BlockBalanceTrace_BlockIdentifier__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} BlockBalanceTrace_BlockIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockBalanceTrace_BlockIdentifier_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockBalanceTrace_BlockIdentifier__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockBalanceTrace_BlockIdentifier_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockBalanceTrace_BlockIdentifier__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockBalanceTrace_BlockIdentifier class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockBalanceTrace_BlockIdentifier__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BlockBalanceTrace)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountTrace

@implementation AccountTrace

@dynamic balance;
@dynamic placeholder;

typedef struct AccountTrace__storage_ {
  uint32_t _has_storage_[1];
  int64_t balance;
  int64_t placeholder;
} AccountTrace__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountTrace_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountTrace__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "placeholder",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountTrace_FieldNumber_Placeholder,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountTrace__storage_, placeholder),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountTrace class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountTrace__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountIdentifier

@implementation AccountIdentifier

@dynamic address;

typedef struct AccountIdentifier__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} AccountIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountIdentifier_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountIdentifier__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountIdentifier class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountIdentifier__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountBalanceRequest

@implementation AccountBalanceRequest

@dynamic hasAccountIdentifier, accountIdentifier;
@dynamic hasBlockIdentifier, blockIdentifier;

typedef struct AccountBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
  AccountIdentifier *accountIdentifier;
  BlockBalanceTrace_BlockIdentifier *blockIdentifier;
} AccountBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountIdentifier",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountIdentifier),
        .number = AccountBalanceRequest_FieldNumber_AccountIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountBalanceRequest__storage_, accountIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockIdentifier",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockBalanceTrace_BlockIdentifier),
        .number = AccountBalanceRequest_FieldNumber_BlockIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountBalanceRequest__storage_, blockIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountBalanceRequest class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountBalanceRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountBalanceResponse

@implementation AccountBalanceResponse

@dynamic balance;
@dynamic hasBlockIdentifier, blockIdentifier;

typedef struct AccountBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  BlockBalanceTrace_BlockIdentifier *blockIdentifier;
  int64_t balance;
} AccountBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountBalanceResponse_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountBalanceResponse__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockIdentifier",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockBalanceTrace_BlockIdentifier),
        .number = AccountBalanceResponse_FieldNumber_BlockIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountBalanceResponse__storage_, blockIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountBalanceResponse class]
                                     rootClass:[BalanceContractRoot class]
                                          file:BalanceContractRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountBalanceResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
